<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 17: Probabilistic Structures Language Comparison | ATP Course</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --accent-orange: #db6d28;
            --border-color: #30363d;
            --pseudocode-bg: #1a1f35;
            --c-bg: #1a2f1a;
            --python-bg: #2f2a1a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }

        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-purple), var(--accent-blue), var(--accent-green));
            transition: width 0.3s ease;
            z-index: 1000;
        }

        .slides-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 50px 60px;
            display: none;
            opacity: 0;
            transition: opacity 0.4s ease;
            overflow-y: auto;
        }

        .slide.active {
            display: block;
            opacity: 1;
        }

        h1 {
            font-size: 2.5em;
            color: var(--accent-blue);
            margin-bottom: 15px;
        }

        h2 {
            font-size: 2em;
            color: var(--accent-blue);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
        }

        h3 {
            font-size: 1.2em;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        p {
            font-size: 1.1em;
            margin-bottom: 15px;
        }

        .title-slide {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .title-slide h1 {
            font-size: 3em;
        }

        .subtitle {
            font-size: 1.8em;
            color: var(--accent-green);
            margin-bottom: 20px;
        }

        .meta {
            color: var(--text-secondary);
            font-size: 1.1em;
        }

        /* Three Column Layout */
        .three-columns {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 15px 0;
            height: calc(100% - 120px);
        }

        .column {
            background-color: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border-color);
        }

        .column.pseudocod {
            border-top: 3px solid var(--accent-purple);
        }

        .column.c-lang {
            border-top: 3px solid var(--accent-green);
        }

        .column.python {
            border-top: 3px solid var(--accent-yellow);
        }

        .column-header {
            padding: 12px 15px;
            background-color: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
        }

        .column.pseudocod .column-header {
            color: var(--accent-purple);
        }

        .column.c-lang .column-header {
            color: var(--accent-green);
        }

        .column.python .column-header {
            color: var(--accent-yellow);
        }

        .column-content {
            padding: 15px;
            flex: 1;
            overflow-y: auto;
        }

        .column-content pre {
            margin: 0;
            font-size: 0.85em;
        }

        .column-content code {
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.4;
        }

        /* Pseudocode styling */
        .pseudocode {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            line-height: 1.5;
            white-space: pre-wrap;
            color: var(--text-primary);
        }

        .pseudocode .keyword {
            color: var(--accent-purple);
            font-weight: 600;
        }

        .pseudocode .function {
            color: var(--accent-blue);
        }

        .pseudocode .comment {
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Two Column Layout */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }

        .two-columns ul {
            list-style: none;
            padding: 0;
        }

        .two-columns li {
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }

        /* Comparison Table */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background-color: var(--bg-tertiary);
            font-weight: 600;
        }

        th:nth-child(1) { color: var(--accent-blue); }
        th:nth-child(2) { color: var(--accent-purple); }
        th:nth-child(3) { color: var(--accent-green); }
        th:nth-child(4) { color: var(--accent-yellow); }

        /* Info boxes */
        .info-box {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid;
        }

        .info-box.insight {
            background-color: rgba(88, 166, 255, 0.1);
            border-color: var(--accent-blue);
        }

        .info-box.note {
            background-color: rgba(210, 153, 34, 0.1);
            border-color: var(--accent-yellow);
        }

        .info-box.warning {
            background-color: rgba(248, 81, 73, 0.1);
            border-color: var(--accent-red);
        }

        .info-box.success {
            background-color: rgba(63, 185, 80, 0.1);
            border-color: var(--accent-green);
        }

        /* Summary grid */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 25px;
            margin-top: 20px;
        }

        .summary-box {
            background-color: var(--bg-secondary);
            padding: 25px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .summary-box .icon {
            font-size: 2.5em;
            margin-bottom: 15px;
        }

        .summary-box h4 {
            color: var(--accent-blue);
            margin-bottom: 10px;
        }

        .summary-box ul {
            list-style: none;
            padding: 0;
            font-size: 0.9em;
        }

        .summary-box li {
            padding: 5px 0;
            color: var(--text-secondary);
        }

        /* Complexity badges */
        .complexity-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
            margin: 2px;
        }

        .complexity-badge.excellent {
            background-color: rgba(63, 185, 80, 0.2);
            color: var(--accent-green);
        }

        .complexity-badge.good {
            background-color: rgba(88, 166, 255, 0.2);
            color: var(--accent-blue);
        }

        .complexity-badge.moderate {
            background-color: rgba(210, 153, 34, 0.2);
            color: var(--accent-yellow);
        }

        /* Navigation */
        .slide-counter {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--bg-secondary);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            border: 1px solid var(--border-color);
        }

        .navigation {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .nav-btn {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .nav-btn:hover:not(:disabled) {
            background-color: var(--bg-tertiary);
            border-color: var(--accent-blue);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        kbd {
            background-color: var(--bg-tertiary);
            padding: 4px 10px;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            border: 1px solid var(--border-color);
        }

        /* Code annotations */
        .code-note {
            color: var(--accent-orange);
            font-size: 0.85em;
            margin-top: 5px;
            font-style: italic;
        }

        /* Formula box */
        .formula-box {
            background-color: var(--bg-tertiary);
            padding: 15px 20px;
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1em;
            margin: 15px 0;
            border: 1px solid var(--border-color);
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progressBar"></div>

    <div class="slides-container">

        <!-- Slide 1: Title -->
        <div class="slide title-slide active">
            <h1>üî¨ Probabilistic Data Structures</h1>
            <div class="subtitle">Language Comparison: Pseudocode vs C vs Python</div>
            <p class="meta">Week 17 | ATP Course | ASE-CSIE Bucharest</p>
            <p style="margin-top: 30px; color: var(--text-secondary);">
                Navigate: <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> or <kbd>Space</kbd>
            </p>
        </div>

        <!-- Slide 2: Why Compare? -->
        <div class="slide">
            <h2>üéØ Why Compare Languages?</h2>
            <div class="two-columns">
                <div>
                    <h3 style="color: var(--accent-purple);">üìù Pseudocode</h3>
                    <ul>
                        <li>Focus on algorithm logic</li>
                        <li>Language-agnostic understanding</li>
                        <li>No implementation details</li>
                        <li>Perfect for whiteboards</li>
                        <li>Academic communication</li>
                    </ul>
                </div>
                <div>
                    <h3 style="color: var(--accent-green);">‚öôÔ∏è C Implementation</h3>
                    <ul>
                        <li>Manual memory control</li>
                        <li>Explicit bit manipulation</li>
                        <li>Maximum performance</li>
                        <li>System-level understanding</li>
                        <li>Production databases use C</li>
                    </ul>
                </div>
            </div>
            <div style="margin-top: 30px;">
                <h3 style="color: var(--accent-yellow);">üêç Python Reference</h3>
                <p>Concise syntax helps verify understanding. Libraries like <code>mmh3</code>, <code>bitarray</code> and <code>datasketch</code> provide production implementations.</p>
            </div>
            <div class="info-box insight">
                <strong>Key Insight:</strong> Probabilistic structures trade exact answers for massive memory savings. Understanding this trade-off transcends any single language.
            </div>
        </div>

        <!-- Slide 3: Bloom Filter - Structure -->
        <div class="slide">
            <h2>üå∏ Bloom Filter: Structure</h2>
            <div class="three-columns">
                <div class="column pseudocod">
                    <div class="column-header">üìù Pseudocode</div>
                    <div class="column-content">
                        <pre class="pseudocode"><span class="keyword">STRUCTURE</span> <span class="function">BloomFilter</span>:
    bits[0..m-1]    <span class="comment">// bit array</span>
    k               <span class="comment">// number of hashes</span>
    n               <span class="comment">// items inserted</span>

<span class="keyword">FUNCTION</span> <span class="function">Create</span>(expected_n, fp_rate):
    <span class="comment">// Optimal bit count</span>
    m ‚Üê -n √ó ln(fp_rate) / (ln(2))¬≤
    
    <span class="comment">// Optimal hash count</span>
    k ‚Üê (m/n) √ó ln(2)
    
    <span class="comment">// Initialise empty</span>
    <span class="keyword">FOR</span> i ‚Üê 0 <span class="keyword">TO</span> m-1:
        bits[i] ‚Üê 0
    
    <span class="keyword">RETURN</span> BloomFilter</pre>
                    </div>
                </div>
                <div class="column c-lang">
                    <div class="column-header">‚öôÔ∏è C</div>
                    <div class="column-content">
                        <pre><code class="language-c">typedef struct {
    uint8_t *bits;     // Bit array
    size_t num_bits;   // m
    size_t num_hashes; // k
    size_t num_items;  // n
} BloomFilter;

BloomFilter *bloom_create(
    size_t expected_n,
    double fp_rate
) {
    BloomFilter *bf = malloc(
        sizeof(BloomFilter));
    if (!bf) return NULL;
    
    // Optimal parameters
    double ln2 = log(2.0);
    size_t m = (size_t)(
        -expected_n * log(fp_rate) 
        / (ln2 * ln2));
    size_t k = (size_t)(
        (m / expected_n) * ln2);
    
    bf->num_bits = m;
    bf->num_hashes = k;
    bf->num_items = 0;
    
    // Allocate byte array
    size_t bytes = (m + 7) / 8;
    bf->bits = calloc(bytes, 1);
    
    return bf;
}</code></pre>
                    </div>
                </div>
                <div class="column python">
                    <div class="column-header">üêç Python</div>
                    <div class="column-content">
                        <pre><code class="language-python">import math

class BloomFilter:
    def __init__(self, 
                 expected_n, 
                 fp_rate=0.01):
        # Optimal parameters
        ln2 = math.log(2)
        self.m = int(
            -expected_n * 
            math.log(fp_rate) / 
            (ln2 ** 2))
        self.k = int(
            (self.m / expected_n) 
            * ln2)
        
        # Bit array as bytearray
        self.bits = bytearray(
            (self.m + 7) // 8)
        self.n = 0
    
    # Or use bitarray library:
    # from bitarray import bitarray
    # self.bits = bitarray(self.m)
    # self.bits.setall(0)</code></pre>
                    </div>
                </div>
            </div>
            <div class="formula-box">
                Optimal: m = -n √ó ln(p) / (ln 2)¬≤ &nbsp;&nbsp;|&nbsp;&nbsp; k = (m/n) √ó ln 2 &nbsp;&nbsp;|&nbsp;&nbsp; ~10 bits/element for 1% FP
            </div>
        </div>

        <!-- Slide 4: Bloom Filter - Insert -->
        <div class="slide">
            <h2>üå∏ Bloom Filter: Insert Operation</h2>
            <div class="three-columns">
                <div class="column pseudocod">
                    <div class="column-header">üìù Pseudocode</div>
                    <div class="column-content">
                        <pre class="pseudocode"><span class="keyword">FUNCTION</span> <span class="function">Insert</span>(bf, element):
    <span class="comment">// Generate k hash positions</span>
    <span class="keyword">FOR</span> i ‚Üê 0 <span class="keyword">TO</span> bf.k - 1:
        pos ‚Üê Hash(element, i) <span class="keyword">MOD</span> bf.m
        bf.bits[pos] ‚Üê 1
    
    bf.n ‚Üê bf.n + 1

<span class="comment">// Kirsch-Mitzenmacher optimisation:</span>
<span class="comment">// Generate k hashes from 2 base hashes</span>
<span class="keyword">FUNCTION</span> <span class="function">Hash</span>(element, i):
    h1 ‚Üê Hash1(element)
    h2 ‚Üê Hash2(element)
    <span class="keyword">RETURN</span> h1 + i √ó h2</pre>
                    </div>
                </div>
                <div class="column c-lang">
                    <div class="column-header">‚öôÔ∏è C</div>
                    <div class="column-content">
                        <pre><code class="language-c">// Set bit at position
static inline void set_bit(
    BloomFilter *bf, size_t pos
) {
    bf->bits[pos / 8] |= 
        (1 << (pos % 8));
}

// Kirsch-Mitzenmacher hashing
void bloom_insert(
    BloomFilter *bf,
    const char *element
) {
    uint32_t h1 = murmur3(
        element, strlen(element), 0);
    uint32_t h2 = murmur3(
        element, strlen(element), h1);
    
    for (size_t i = 0; 
         i < bf->num_hashes; i++) {
        size_t pos = (h1 + i * h2) 
                     % bf->num_bits;
        set_bit(bf, pos);
    }
    bf->num_items++;
}</code></pre>
                    </div>
                </div>
                <div class="column python">
                    <div class="column-header">üêç Python</div>
                    <div class="column-content">
                        <pre><code class="language-python">import mmh3  # MurmurHash3

def _set_bit(self, pos):
    self.bits[pos // 8] |= (
        1 << (pos % 8))

def insert(self, element):
    # Kirsch-Mitzenmacher
    h1 = mmh3.hash(element, 0)
    h2 = mmh3.hash(element, h1)
    
    for i in range(self.k):
        pos = (h1 + i * h2) % self.m
        self._set_bit(pos)
    
    self.n += 1

# With bitarray:
# for i in range(self.k):
#     pos = (h1 + i * h2) % self.m
#     self.bits[pos] = True</code></pre>
                    </div>
                </div>
            </div>
            <div class="info-box note">
                <strong>Kirsch-Mitzenmacher:</strong> Instead of k independent hashes, use h(i) = h‚ÇÅ + i√óh‚ÇÇ. Same theoretical guarantees with only 2 hash computations.
            </div>
        </div>

        <!-- Slide 5: Bloom Filter - Query -->
        <div class="slide">
            <h2>üå∏ Bloom Filter: Query Operation</h2>
            <div class="three-columns">
                <div class="column pseudocod">
                    <div class="column-header">üìù Pseudocode</div>
                    <div class="column-content">
                        <pre class="pseudocode"><span class="keyword">FUNCTION</span> <span class="function">Query</span>(bf, element):
    <span class="comment">// Check all k positions</span>
    <span class="keyword">FOR</span> i ‚Üê 0 <span class="keyword">TO</span> bf.k - 1:
        pos ‚Üê Hash(element, i) <span class="keyword">MOD</span> bf.m
        
        <span class="keyword">IF</span> bf.bits[pos] = 0:
            <span class="keyword">RETURN</span> <span class="keyword">FALSE</span>  <span class="comment">// Definitely not present</span>
    
    <span class="keyword">RETURN</span> <span class="keyword">TRUE</span>  <span class="comment">// Probably present</span>

<span class="comment">// Note: FALSE = definitely absent</span>
<span class="comment">//       TRUE  = maybe present (FP possible)</span></pre>
                    </div>
                </div>
                <div class="column c-lang">
                    <div class="column-header">‚öôÔ∏è C</div>
                    <div class="column-content">
                        <pre><code class="language-c">// Get bit at position
static inline bool get_bit(
    BloomFilter *bf, size_t pos
) {
    return bf->bits[pos / 8] & 
           (1 << (pos % 8));
}

bool bloom_query(
    BloomFilter *bf,
    const char *element
) {
    uint32_t h1 = murmur3(
        element, strlen(element), 0);
    uint32_t h2 = murmur3(
        element, strlen(element), h1);
    
    for (size_t i = 0; 
         i < bf->num_hashes; i++) {
        size_t pos = (h1 + i * h2) 
                     % bf->num_bits;
        if (!get_bit(bf, pos)) {
            return false;
        }
    }
    return true;  // Maybe present
}</code></pre>
                    </div>
                </div>
                <div class="column python">
                    <div class="column-header">üêç Python</div>
                    <div class="column-content">
                        <pre><code class="language-python">def _get_bit(self, pos):
    return bool(
        self.bits[pos // 8] & 
        (1 << (pos % 8)))

def query(self, element):
    h1 = mmh3.hash(element, 0)
    h2 = mmh3.hash(element, h1)
    
    for i in range(self.k):
        pos = (h1 + i * h2) % self.m
        if not self._get_bit(pos):
            return False
    
    return True  # Probably present

def __contains__(self, element):
    """Enables 'in' operator"""
    return self.query(element)

# Usage:
# if "apple" in bloom_filter:
#     print("Probably present")</code></pre>
                    </div>
                </div>
            </div>
            <div class="info-box warning">
                <strong>Critical Understanding:</strong> <code>query() = False</code> means <em>definitely not present</em>. <code>query() = True</code> means <em>probably present</em> (false positive rate ‚âà p).
            </div>
        </div>

        <!-- Slide 6: Count-Min Sketch - Structure -->
        <div class="slide">
            <h2>üìä Count-Min Sketch: Structure</h2>
            <div class="three-columns">
                <div class="column pseudocod">
                    <div class="column-header">üìù Pseudocode</div>
                    <div class="column-content">
                        <pre class="pseudocode"><span class="keyword">STRUCTURE</span> <span class="function">CountMinSketch</span>:
    table[d][w]  <span class="comment">// d rows, w columns</span>
    width        <span class="comment">// w = ‚åàe/Œµ‚åâ</span>
    depth        <span class="comment">// d = ‚åàln(1/Œ¥)‚åâ</span>

<span class="keyword">FUNCTION</span> <span class="function">Create</span>(epsilon, delta):
    <span class="comment">// Œµ = error bound (additive)</span>
    <span class="comment">// Œ¥ = failure probability</span>
    
    w ‚Üê ‚åàe / epsilon‚åâ
    d ‚Üê ‚åàln(1 / delta)‚åâ
    
    <span class="comment">// Initialise counters to 0</span>
    <span class="keyword">FOR</span> i ‚Üê 0 <span class="keyword">TO</span> d-1:
        <span class="keyword">FOR</span> j ‚Üê 0 <span class="keyword">TO</span> w-1:
            table[i][j] ‚Üê 0
    
    <span class="keyword">RETURN</span> CountMinSketch</pre>
                    </div>
                </div>
                <div class="column c-lang">
                    <div class="column-header">‚öôÔ∏è C</div>
                    <div class="column-content">
                        <pre><code class="language-c">typedef struct {
    uint32_t **table;
    size_t width;
    size_t depth;
    size_t total_count;
} CountMinSketch;

CountMinSketch *cms_create(
    double epsilon, 
    double delta
) {
    CountMinSketch *cms = malloc(
        sizeof(CountMinSketch));
    if (!cms) return NULL;
    
    cms->width = (size_t)ceil(
        M_E / epsilon);
    cms->depth = (size_t)ceil(
        log(1.0 / delta));
    cms->total_count = 0;
    
    // Allocate 2D array
    cms->table = malloc(
        cms->depth * sizeof(uint32_t*));
    for (size_t i = 0; 
         i < cms->depth; i++) {
        cms->table[i] = calloc(
            cms->width, sizeof(uint32_t));
    }
    return cms;
}</code></pre>
                    </div>
                </div>
                <div class="column python">
                    <div class="column-header">üêç Python</div>
                    <div class="column-content">
                        <pre><code class="language-python">import math

class CountMinSketch:
    def __init__(self, 
                 epsilon=0.01, 
                 delta=0.01):
        # Width and depth
        self.w = int(math.ceil(
            math.e / epsilon))
        self.d = int(math.ceil(
            math.log(1.0 / delta)))
        
        # 2D table of counters
        self.table = [
            [0] * self.w 
            for _ in range(self.d)
        ]
        self.total = 0
    
    # Alternative: numpy
    # import numpy as np
    # self.table = np.zeros(
    #     (self.d, self.w), 
    #     dtype=np.uint32)</code></pre>
                    </div>
                </div>
            </div>
            <div class="formula-box">
                Guarantee: estimate ‚â§ true_count + Œµ √ó N with probability ‚â• 1 - Œ¥
            </div>
        </div>

        <!-- Slide 7: Count-Min Sketch - Update -->
        <div class="slide">
            <h2>üìä Count-Min Sketch: Update Operation</h2>
            <div class="three-columns">
                <div class="column pseudocod">
                    <div class="column-header">üìù Pseudocode</div>
                    <div class="column-content">
                        <pre class="pseudocode"><span class="keyword">FUNCTION</span> <span class="function">Update</span>(cms, element, count):
    <span class="comment">// Increment counter in each row</span>
    <span class="keyword">FOR</span> i ‚Üê 0 <span class="keyword">TO</span> cms.depth - 1:
        <span class="comment">// Each row uses different hash</span>
        j ‚Üê Hash(element, seed=i) <span class="keyword">MOD</span> cms.width
        
        cms.table[i][j] ‚Üê cms.table[i][j] + count

<span class="comment">// Simple increment wrapper:</span>
<span class="keyword">FUNCTION</span> <span class="function">Add</span>(cms, element):
    Update(cms, element, 1)</pre>
                    </div>
                </div>
                <div class="column c-lang">
                    <div class="column-header">‚öôÔ∏è C</div>
                    <div class="column-content">
                        <pre><code class="language-c">void cms_update(
    CountMinSketch *cms,
    const char *element,
    uint32_t count
) {
    size_t len = strlen(element);
    
    for (size_t i = 0; 
         i < cms->depth; i++) {
        // Different seed per row
        uint32_t hash = murmur3(
            element, len, i);
        size_t j = hash % cms->width;
        
        cms->table[i][j] += count;
    }
    cms->total_count += count;
}

// Convenience function
void cms_add(
    CountMinSketch *cms,
    const char *element
) {
    cms_update(cms, element, 1);
}</code></pre>
                    </div>
                </div>
                <div class="column python">
                    <div class="column-header">üêç Python</div>
                    <div class="column-content">
                        <pre><code class="language-python">def update(self, element, count=1):
    for i in range(self.d):
        # Different seed per row
        h = mmh3.hash(element, i)
        j = h % self.w
        self.table[i][j] += count
    
    self.total += count

def add(self, element):
    """Convenience wrapper"""
    self.update(element, 1)

# Batch update
def add_many(self, elements):
    for elem in elements:
        self.add(elem)</code></pre>
                    </div>
                </div>
            </div>
            <div class="info-box insight">
                <strong>Why d rows?</strong> Each row gives an independent estimate. Taking minimum across rows reduces error probability exponentially: P(all wrong) = Œ¥^d.
            </div>
        </div>

        <!-- Slide 8: Count-Min Sketch - Query -->
        <div class="slide">
            <h2>üìä Count-Min Sketch: Query Operation</h2>
            <div class="three-columns">
                <div class="column pseudocod">
                    <div class="column-header">üìù Pseudocode</div>
                    <div class="column-content">
                        <pre class="pseudocode"><span class="keyword">FUNCTION</span> <span class="function">Query</span>(cms, element):
    min_count ‚Üê ‚àû
    
    <span class="keyword">FOR</span> i ‚Üê 0 <span class="keyword">TO</span> cms.depth - 1:
        j ‚Üê Hash(element, seed=i) <span class="keyword">MOD</span> cms.width
        
        <span class="keyword">IF</span> cms.table[i][j] < min_count:
            min_count ‚Üê cms.table[i][j]
    
    <span class="keyword">RETURN</span> min_count

<span class="comment">// Note: Returns UPPER BOUND</span>
<span class="comment">// estimate ‚â• true_count (always)</span>
<span class="comment">// estimate ‚â§ true + Œµ√óN (with prob 1-Œ¥)</span></pre>
                    </div>
                </div>
                <div class="column c-lang">
                    <div class="column-header">‚öôÔ∏è C</div>
                    <div class="column-content">
                        <pre><code class="language-c">uint32_t cms_query(
    CountMinSketch *cms,
    const char *element
) {
    size_t len = strlen(element);
    uint32_t min_count = UINT32_MAX;
    
    for (size_t i = 0; 
         i < cms->depth; i++) {
        uint32_t hash = murmur3(
            element, len, i);
        size_t j = hash % cms->width;
        
        if (cms->table[i][j] < min_count) {
            min_count = cms->table[i][j];
        }
    }
    return min_count;
}

// Note: Always overestimates
// due to hash collisions</code></pre>
                    </div>
                </div>
                <div class="column python">
                    <div class="column-header">üêç Python</div>
                    <div class="column-content">
                        <pre><code class="language-python">def query(self, element):
    estimates = []
    
    for i in range(self.d):
        h = mmh3.hash(element, i)
        j = h % self.w
        estimates.append(
            self.table[i][j])
    
    return min(estimates)

# Pythonic one-liner:
def query_compact(self, element):
    return min(
        self.table[i][
            mmh3.hash(element, i) 
            % self.w
        ]
        for i in range(self.d)
    )</code></pre>
                    </div>
                </div>
            </div>
            <div class="info-box warning">
                <strong>One-Sided Error:</strong> CMS always <em>overestimates</em>. If query returns 0, the element was never seen. If it returns n, true count is ‚â§ n.
            </div>
        </div>

        <!-- Slide 9: HyperLogLog - Structure -->
        <div class="slide">
            <h2>üìê HyperLogLog: Structure</h2>
            <div class="three-columns">
                <div class="column pseudocod">
                    <div class="column-header">üìù Pseudocode</div>
                    <div class="column-content">
                        <pre class="pseudocode"><span class="keyword">STRUCTURE</span> <span class="function">HyperLogLog</span>:
    registers[0..m-1]  <span class="comment">// m = 2^p registers</span>
    precision          <span class="comment">// p bits for bucket index</span>

<span class="keyword">FUNCTION</span> <span class="function">Create</span>(precision):
    <span class="comment">// p typically 4-18</span>
    <span class="comment">// Higher p = more accuracy, more memory</span>
    
    m ‚Üê 2^precision
    
    <span class="keyword">FOR</span> i ‚Üê 0 <span class="keyword">TO</span> m-1:
        registers[i] ‚Üê 0
    
    <span class="keyword">RETURN</span> HyperLogLog

<span class="comment">// Memory: ~1.5 KB for p=14</span>
<span class="comment">// Error: ~1.04 / ‚àöm ‚âà 0.81%</span></pre>
                    </div>
                </div>
                <div class="column c-lang">
                    <div class="column-header">‚öôÔ∏è C</div>
                    <div class="column-content">
                        <pre><code class="language-c">typedef struct {
    uint8_t *registers;
    uint8_t precision;  // p
    size_t num_registers; // m = 2^p
} HyperLogLog;

HyperLogLog *hll_create(
    uint8_t precision
) {
    if (precision < 4 || 
        precision > 18) {
        return NULL;
    }
    
    HyperLogLog *hll = malloc(
        sizeof(HyperLogLog));
    if (!hll) return NULL;
    
    hll->precision = precision;
    hll->num_registers = 
        1 << precision;  // 2^p
    
    hll->registers = calloc(
        hll->num_registers, 
        sizeof(uint8_t));
    
    return hll;
}</code></pre>
                    </div>
                </div>
                <div class="column python">
                    <div class="column-header">üêç Python</div>
                    <div class="column-content">
                        <pre><code class="language-python">class HyperLogLog:
    def __init__(self, precision=14):
        if not 4 <= precision <= 18:
            raise ValueError(
                "Precision must be 4-18")
        
        self.p = precision
        self.m = 1 << precision  # 2^p
        self.registers = [0] * self.m
    
    @property
    def error_rate(self):
        """Theoretical error"""
        return 1.04 / (self.m ** 0.5)

# Memory for common precisions:
# p=10: 1 KB,  ~3.25% error
# p=14: 16 KB, ~0.81% error
# p=18: 256 KB, ~0.20% error</code></pre>
                    </div>
                </div>
            </div>
            <div class="formula-box">
                m = 2^p registers &nbsp;&nbsp;|&nbsp;&nbsp; Memory ‚âà m bytes &nbsp;&nbsp;|&nbsp;&nbsp; Error ‚âà 1.04/‚àöm
            </div>
        </div>

        <!-- Slide 10: HyperLogLog - Add -->
        <div class="slide">
            <h2>üìê HyperLogLog: Add Operation</h2>
            <div class="three-columns">
                <div class="column pseudocod">
                    <div class="column-header">üìù Pseudocode</div>
                    <div class="column-content">
                        <pre class="pseudocode"><span class="keyword">FUNCTION</span> <span class="function">Add</span>(hll, element):
    hash ‚Üê Hash64(element)
    
    <span class="comment">// First p bits = register index</span>
    index ‚Üê hash >> (64 - hll.precision)
    
    <span class="comment">// Remaining bits for leading zeros</span>
    remaining ‚Üê hash << hll.precision
    
    <span class="comment">// Count leading zeros + 1</span>
    rho ‚Üê LeadingZeros(remaining) + 1
    
    <span class="comment">// Update register with max</span>
    <span class="keyword">IF</span> rho > hll.registers[index]:
        hll.registers[index] ‚Üê rho

<span class="keyword">FUNCTION</span> <span class="function">LeadingZeros</span>(bits):
    count ‚Üê 0
    <span class="keyword">WHILE</span> (bits AND MSB) = 0:
        count ‚Üê count + 1
        bits ‚Üê bits << 1
    <span class="keyword">RETURN</span> count</pre>
                    </div>
                </div>
                <div class="column c-lang">
                    <div class="column-header">‚öôÔ∏è C</div>
                    <div class="column-content">
                        <pre><code class="language-c">// Count leading zeros
static inline uint8_t clz64(
    uint64_t x
) {
    if (x == 0) return 64;
    return __builtin_clzll(x);
}

void hll_add(
    HyperLogLog *hll,
    const char *element
) {
    // 64-bit hash
    uint64_t hash = murmur3_64(
        element, strlen(element), 0);
    
    // First p bits = index
    size_t index = hash >> 
        (64 - hll->precision);
    
    // Remaining bits
    uint64_t remaining = hash << 
        hll->precision;
    
    // Leading zeros + 1
    uint8_t rho = clz64(remaining) + 1;
    
    // Update max
    if (rho > hll->registers[index]) {
        hll->registers[index] = rho;
    }
}</code></pre>
                    </div>
                </div>
                <div class="column python">
                    <div class="column-header">üêç Python</div>
                    <div class="column-content">
                        <pre><code class="language-python">def _leading_zeros(self, x, bits=64):
    """Count leading zeros"""
    if x == 0:
        return bits
    count = 0
    mask = 1 << (bits - 1)
    while (x & mask) == 0:
        count += 1
        mask >>= 1
    return count

def add(self, element):
    # 64-bit hash (unsigned)
    h = mmh3.hash64(element)[0]
    h = h & 0xFFFFFFFFFFFFFFFF
    
    # First p bits = index
    index = h >> (64 - self.p)
    
    # Remaining bits
    remaining = (h << self.p) & (
        (1 << 64) - 1)
    
    # Leading zeros + 1
    rho = self._leading_zeros(
        remaining, 64 - self.p) + 1
    
    # Update max
    self.registers[index] = max(
        self.registers[index], rho)</code></pre>
                    </div>
                </div>
            </div>
            <div class="info-box insight">
                <strong>Intuition:</strong> More unique elements ‚Üí more chances of seeing rare patterns (many leading zeros). Maximum observed zeros estimates log‚ÇÇ(cardinality).
            </div>
        </div>

        <!-- Slide 11: HyperLogLog - Count -->
        <div class="slide">
            <h2>üìê HyperLogLog: Cardinality Estimation</h2>
            <div class="three-columns">
                <div class="column pseudocod">
                    <div class="column-header">üìù Pseudocode</div>
                    <div class="column-content">
                        <pre class="pseudocode"><span class="keyword">FUNCTION</span> <span class="function">Count</span>(hll):
    <span class="comment">// Harmonic mean of 2^(-register)</span>
    sum ‚Üê 0
    <span class="keyword">FOR</span> i ‚Üê 0 <span class="keyword">TO</span> m-1:
        sum ‚Üê sum + 2^(-registers[i])
    
    <span class="comment">// Raw estimate</span>
    E ‚Üê Œ±_m √ó m¬≤ / sum
    
    <span class="comment">// Bias corrections</span>
    <span class="keyword">IF</span> E ‚â§ 2.5 √ó m:  <span class="comment">// Small range</span>
        V ‚Üê CountZeroRegisters()
        <span class="keyword">IF</span> V > 0:
            E ‚Üê m √ó ln(m / V)
    <span class="keyword">ELSE IF</span> E > 2^32 / 30:  <span class="comment">// Large range</span>
        E ‚Üê -2^32 √ó ln(1 - E/2^32)
    
    <span class="keyword">RETURN</span> E</pre>
                    </div>
                </div>
                <div class="column c-lang">
                    <div class="column-header">‚öôÔ∏è C</div>
                    <div class="column-content">
                        <pre><code class="language-c">// Bias correction constant
static double alpha_m(size_t m) {
    switch (m) {
        case 16:  return 0.673;
        case 32:  return 0.697;
        case 64:  return 0.709;
        default:  return 0.7213 / 
            (1 + 1.079 / m);
    }
}

double hll_count(HyperLogLog *hll) {
    double sum = 0.0;
    size_t zeros = 0;
    
    for (size_t i = 0; 
         i < hll->num_registers; i++) {
        sum += pow(2.0, 
            -hll->registers[i]);
        if (hll->registers[i] == 0)
            zeros++;
    }
    
    double alpha = alpha_m(
        hll->num_registers);
    double m = hll->num_registers;
    double E = alpha * m * m / sum;
    
    // Small range correction
    if (E <= 2.5 * m && zeros > 0) {
        E = m * log(m / zeros);
    }
    return E;
}</code></pre>
                    </div>
                </div>
                <div class="column python">
                    <div class="column-header">üêç Python</div>
                    <div class="column-content">
                        <pre><code class="language-python">def _alpha(self):
    """Bias correction constant"""
    if self.m == 16: return 0.673
    if self.m == 32: return 0.697
    if self.m == 64: return 0.709
    return 0.7213 / (1 + 1.079/self.m)

def count(self):
    # Harmonic mean
    sum_inv = sum(
        2.0 ** (-r) 
        for r in self.registers)
    
    # Raw estimate
    alpha = self._alpha()
    E = alpha * self.m**2 / sum_inv
    
    # Small range correction
    zeros = self.registers.count(0)
    if E <= 2.5 * self.m and zeros > 0:
        E = self.m * math.log(
            self.m / zeros)
    
    return int(E)

def __len__(self):
    return self.count()</code></pre>
                    </div>
                </div>
            </div>
            <div class="info-box note">
                <strong>Why Harmonic Mean?</strong> Arithmetic mean is skewed by outliers. Harmonic mean gives more weight to smaller values, improving accuracy for cardinality estimation.
            </div>
        </div>

        <!-- Slide 12: Skip List - Structure -->
        <div class="slide">
            <h2>ü™ú Skip List: Structure</h2>
            <div class="three-columns">
                <div class="column pseudocod">
                    <div class="column-header">üìù Pseudocode</div>
                    <div class="column-content">
                        <pre class="pseudocode"><span class="keyword">STRUCTURE</span> <span class="function">SkipNode</span>:
    key
    value
    level        <span class="comment">// Node height</span>
    forward[]    <span class="comment">// Pointers to next nodes</span>

<span class="keyword">STRUCTURE</span> <span class="function">SkipList</span>:
    header       <span class="comment">// Sentinel node</span>
    max_level    <span class="comment">// Maximum allowed level</span>
    level        <span class="comment">// Current highest level</span>
    p            <span class="comment">// Probability (usually 0.5)</span>

<span class="keyword">FUNCTION</span> <span class="function">RandomLevel</span>(max_level, p):
    level ‚Üê 1
    <span class="keyword">WHILE</span> Random() < p <span class="keyword">AND</span> level < max_level:
        level ‚Üê level + 1
    <span class="keyword">RETURN</span> level</pre>
                    </div>
                </div>
                <div class="column c-lang">
                    <div class="column-header">‚öôÔ∏è C</div>
                    <div class="column-content">
                        <pre><code class="language-c">typedef struct SkipNode {
    int key;
    void *value;
    int level;
    struct SkipNode **forward;
} SkipNode;

typedef struct {
    SkipNode *header;
    int max_level;
    int level;
    double p;
} SkipList;

int random_level(
    int max_level, double p
) {
    int level = 1;
    while ((double)rand() / RAND_MAX 
           < p && level < max_level) {
        level++;
    }
    return level;
}

SkipNode *create_node(
    int key, void *value, int level
) {
    SkipNode *node = malloc(
        sizeof(SkipNode));
    node->forward = calloc(level,
        sizeof(SkipNode*));
    node->key = key;
    node->value = value;
    node->level = level;
    return node;
}</code></pre>
                    </div>
                </div>
                <div class="column python">
                    <div class="column-header">üêç Python</div>
                    <div class="column-content">
                        <pre><code class="language-python">import random

class SkipNode:
    def __init__(self, key, value, 
                 level):
        self.key = key
        self.value = value
        self.forward = [None] * level

class SkipList:
    def __init__(self, max_level=16, 
                 p=0.5):
        self.max_level = max_level
        self.p = p
        self.level = 1
        # Sentinel header
        self.header = SkipNode(
            None, None, max_level)
    
    def _random_level(self):
        level = 1
        while (random.random() < self.p 
               and level < self.max_level):
            level += 1
        return level</code></pre>
                    </div>
                </div>
            </div>
            <div class="info-box insight">
                <strong>Probabilistic Balance:</strong> Unlike AVL/Red-Black trees requiring rotations, Skip Lists achieve O(log n) expected time through randomisation. Simpler to implement!
            </div>
        </div>

        <!-- Slide 13: Skip List - Search -->
        <div class="slide">
            <h2>ü™ú Skip List: Search Operation</h2>
            <div class="three-columns">
                <div class="column pseudocod">
                    <div class="column-header">üìù Pseudocode</div>
                    <div class="column-content">
                        <pre class="pseudocode"><span class="keyword">FUNCTION</span> <span class="function">Search</span>(list, key):
    current ‚Üê list.header
    
    <span class="comment">// Start from highest level</span>
    <span class="keyword">FOR</span> i ‚Üê list.level - 1 <span class="keyword">DOWNTO</span> 0:
        <span class="comment">// Move right while possible</span>
        <span class="keyword">WHILE</span> current.forward[i] ‚â† NULL
              <span class="keyword">AND</span> current.forward[i].key < key:
            current ‚Üê current.forward[i]
    
    <span class="comment">// Move to candidate node</span>
    current ‚Üê current.forward[0]
    
    <span class="keyword">IF</span> current ‚â† NULL <span class="keyword">AND</span> current.key = key:
        <span class="keyword">RETURN</span> current.value
    <span class="keyword">ELSE</span>:
        <span class="keyword">RETURN</span> NULL  <span class="comment">// Not found</span></pre>
                    </div>
                </div>
                <div class="column c-lang">
                    <div class="column-header">‚öôÔ∏è C</div>
                    <div class="column-content">
                        <pre><code class="language-c">void *skiplist_search(
    SkipList *list, int key
) {
    SkipNode *current = list->header;
    
    // Start from highest level
    for (int i = list->level - 1; 
         i >= 0; i--) {
        // Move right while possible
        while (current->forward[i] &&
               current->forward[i]->key 
               < key) {
            current = current->forward[i];
        }
    }
    
    // Move to level 0 candidate
    current = current->forward[0];
    
    if (current && current->key == key) {
        return current->value;
    }
    return NULL;  // Not found
}

// Expected: O(log n)
// Worst case: O(n) but very unlikely</code></pre>
                    </div>
                </div>
                <div class="column python">
                    <div class="column-header">üêç Python</div>
                    <div class="column-content">
                        <pre><code class="language-python">def search(self, key):
    current = self.header
    
    # Start from highest level
    for i in range(
        self.level - 1, -1, -1):
        # Move right while possible
        while (current.forward[i] and
               current.forward[i].key 
               < key):
            current = current.forward[i]
    
    # Move to candidate
    current = current.forward[0]
    
    if current and current.key == key:
        return current.value
    return None

def __contains__(self, key):
    return self.search(key) is not None

def __getitem__(self, key):
    val = self.search(key)
    if val is None:
        raise KeyError(key)
    return val</code></pre>
                    </div>
                </div>
            </div>
            <div class="info-box success">
                <strong>Search Pattern:</strong> Start high, go right as far as possible, drop down one level, repeat. Like a "staircase descent" through the structure.
            </div>
        </div>

        <!-- Slide 14: Skip List - Insert -->
        <div class="slide">
            <h2>ü™ú Skip List: Insert Operation</h2>
            <div class="three-columns">
                <div class="column pseudocod">
                    <div class="column-header">üìù Pseudocode</div>
                    <div class="column-content">
                        <pre class="pseudocode"><span class="keyword">FUNCTION</span> <span class="function">Insert</span>(list, key, value):
    update[] ‚Üê empty array of size max_level
    current ‚Üê list.header
    
    <span class="comment">// Find insertion point, track updates</span>
    <span class="keyword">FOR</span> i ‚Üê list.level - 1 <span class="keyword">DOWNTO</span> 0:
        <span class="keyword">WHILE</span> current.forward[i] ‚â† NULL
              <span class="keyword">AND</span> current.forward[i].key < key:
            current ‚Üê current.forward[i]
        update[i] ‚Üê current
    
    <span class="comment">// Determine new node level</span>
    new_level ‚Üê RandomLevel()
    
    <span class="keyword">IF</span> new_level > list.level:
        <span class="keyword">FOR</span> i ‚Üê list.level <span class="keyword">TO</span> new_level - 1:
            update[i] ‚Üê list.header
        list.level ‚Üê new_level
    
    <span class="comment">// Create and insert node</span>
    new_node ‚Üê CreateNode(key, value, new_level)
    <span class="keyword">FOR</span> i ‚Üê 0 <span class="keyword">TO</span> new_level - 1:
        new_node.forward[i] ‚Üê update[i].forward[i]
        update[i].forward[i] ‚Üê new_node</pre>
                    </div>
                </div>
                <div class="column c-lang">
                    <div class="column-header">‚öôÔ∏è C</div>
                    <div class="column-content">
                        <pre><code class="language-c">void skiplist_insert(
    SkipList *list, int key, void *val
) {
    SkipNode *update[list->max_level];
    SkipNode *current = list->header;
    
    // Find position, track updates
    for (int i = list->level - 1; 
         i >= 0; i--) {
        while (current->forward[i] &&
               current->forward[i]->key 
               < key) {
            current = current->forward[i];
        }
        update[i] = current;
    }
    
    // Random level for new node
    int lvl = random_level(
        list->max_level, list->p);
    
    if (lvl > list->level) {
        for (int i = list->level; 
             i < lvl; i++) {
            update[i] = list->header;
        }
        list->level = lvl;
    }
    
    // Create and wire node
    SkipNode *node = create_node(
        key, val, lvl);
    for (int i = 0; i < lvl; i++) {
        node->forward[i] = 
            update[i]->forward[i];
        update[i]->forward[i] = node;
    }
}</code></pre>
                    </div>
                </div>
                <div class="column python">
                    <div class="column-header">üêç Python</div>
                    <div class="column-content">
                        <pre><code class="language-python">def insert(self, key, value):
    update = [None] * self.max_level
    current = self.header
    
    # Find position, track updates
    for i in range(
        self.level - 1, -1, -1):
        while (current.forward[i] and
               current.forward[i].key 
               < key):
            current = current.forward[i]
        update[i] = current
    
    # Random level
    lvl = self._random_level()
    
    if lvl > self.level:
        for i in range(
            self.level, lvl):
            update[i] = self.header
        self.level = lvl
    
    # Create and wire node
    node = SkipNode(key, value, lvl)
    for i in range(lvl):
        node.forward[i] = \
            update[i].forward[i]
        update[i].forward[i] = node

def __setitem__(self, key, value):
    self.insert(key, value)</code></pre>
                    </div>
                </div>
            </div>
            <div class="info-box note">
                <strong>Update Array:</strong> Tracks predecessor at each level. Essential for rewiring pointers during insertion and deletion.
            </div>
        </div>

        <!-- Slide 15: Comparison Table -->
        <div class="slide">
            <h2>üìä Language Comparison Summary</h2>
            <table>
                <tr>
                    <th style="width: 20%;">Aspect</th>
                    <th style="width: 26%;">üìù Pseudocode</th>
                    <th style="width: 27%;">‚öôÔ∏è C</th>
                    <th style="width: 27%;">üêç Python</th>
                </tr>
                <tr>
                    <td><strong>Bit Manipulation</strong></td>
                    <td>Abstract (SET BIT)</td>
                    <td>Explicit (| & << >>)</td>
                    <td>Same operators</td>
                </tr>
                <tr>
                    <td><strong>Hash Functions</strong></td>
                    <td>Hash(element, seed)</td>
                    <td>MurmurHash3 manual</td>
                    <td>mmh3 library</td>
                </tr>
                <tr>
                    <td><strong>Memory</strong></td>
                    <td>Abstract arrays</td>
                    <td>malloc/calloc/free</td>
                    <td>Automatic (GC)</td>
                </tr>
                <tr>
                    <td><strong>2D Arrays</strong></td>
                    <td>table[i][j]</td>
                    <td>Pointer arrays</td>
                    <td>List comprehensions</td>
                </tr>
                <tr>
                    <td><strong>Leading Zeros</strong></td>
                    <td>LeadingZeros(x)</td>
                    <td>__builtin_clzll()</td>
                    <td>Manual loop</td>
                </tr>
                <tr>
                    <td><strong>Random Numbers</strong></td>
                    <td>Random() ‚àà [0,1)</td>
                    <td>rand()/RAND_MAX</td>
                    <td>random.random()</td>
                </tr>
                <tr>
                    <td><strong>Error Handling</strong></td>
                    <td>Usually omitted</td>
                    <td>NULL checks</td>
                    <td>Exceptions</td>
                </tr>
            </table>
        </div>

        <!-- Slide 16: Memory Layout -->
        <div class="slide">
            <h2>üíæ Memory Layout Comparison</h2>
            <div class="three-columns">
                <div class="column pseudocod">
                    <div class="column-header">üìù Pseudocode (Abstract)</div>
                    <div class="column-content">
                        <pre class="pseudocode"><span class="comment">// Bloom Filter: m bits</span>
bits[0..m-1]

<span class="comment">// Count-Min Sketch: d √ó w counters</span>
table[d][w]

<span class="comment">// HyperLogLog: m registers</span>
registers[0..m-1]

<span class="comment">// Skip List: nodes with pointers</span>
node.forward[0..level-1]

<span class="comment">// Memory is abstract</span>
<span class="comment">// No allocation details</span>
<span class="comment">// No deallocation needed</span></pre>
                    </div>
                </div>
                <div class="column c-lang">
                    <div class="column-header">‚öôÔ∏è C (Explicit)</div>
                    <div class="column-content">
                        <pre><code class="language-c">// Bloom: packed bits in bytes
uint8_t *bits = calloc(
    (m + 7) / 8, 1);
// Access: bits[pos/8] & (1<<(pos%8))

// CMS: array of row pointers
uint32_t **table = malloc(
    d * sizeof(uint32_t*));
for (int i = 0; i < d; i++)
    table[i] = calloc(w, 4);

// HLL: byte per register
uint8_t *regs = calloc(m, 1);

// Skip: flexible node size
node->forward = calloc(
    level, sizeof(SkipNode*));

// MUST free everything!
free(bf->bits);
free(bf);</code></pre>
                    </div>
                </div>
                <div class="column python">
                    <div class="column-header">üêç Python (Managed)</div>
                    <div class="column-content">
                        <pre><code class="language-python"># Bloom: bytearray
self.bits = bytearray(
    (m + 7) // 8)
# Or: bitarray(m) from library

# CMS: nested lists
self.table = [
    [0] * w for _ in range(d)]
# Or: numpy.zeros((d,w), uint32)

# HLL: simple list
self.registers = [0] * m

# Skip: list in node
self.forward = [None] * level

# No manual deallocation
# Garbage collector handles it
# Reference counting + cycle GC</code></pre>
                    </div>
                </div>
            </div>
            <div class="info-box warning">
                <strong>C Memory Pitfalls:</strong> Forgetting to free memory, double-free, use-after-free, buffer overflows. Valgrind is essential for detecting leaks.
            </div>
        </div>

        <!-- Slide 17: When to Use Each -->
        <div class="slide">
            <h2>üéØ When to Use Each Language</h2>
            <div class="summary-grid">
                <div class="summary-box">
                    <div class="icon">üìù</div>
                    <h4>Pseudocode</h4>
                    <ul style="text-align: left; font-size: 0.9em;">
                        <li>Algorithm design</li>
                        <li>Academic papers</li>
                        <li>Teaching concepts</li>
                        <li>Whiteboard interviews</li>
                        <li>Documentation</li>
                        <li>Proving correctness</li>
                    </ul>
                </div>
                <div class="summary-box">
                    <div class="icon">‚öôÔ∏è</div>
                    <h4>C</h4>
                    <ul style="text-align: left; font-size: 0.9em;">
                        <li>Production databases</li>
                        <li>Redis, LevelDB</li>
                        <li>Performance-critical code</li>
                        <li>Memory-constrained IoT</li>
                        <li>System libraries</li>
                        <li>Learning low-level details</li>
                    </ul>
                </div>
                <div class="summary-box">
                    <div class="icon">üêç</div>
                    <h4>Python</h4>
                    <ul style="text-align: left; font-size: 0.9em;">
                        <li>Prototyping</li>
                        <li>Data analysis</li>
                        <li>Testing algorithms</li>
                        <li>Quick experiments</li>
                        <li>Using libraries</li>
                        <li>Visualisation</li>
                    </ul>
                </div>
            </div>
            <div class="info-box success">
                <strong>Career Tip:</strong> Understanding the algorithm in pseudocode, implementing it in C for performance, and using Python for rapid testing makes you a versatile engineer.
            </div>
        </div>

        <!-- Slide 18: Key Insights -->
        <div class="slide">
            <h2>üí° Key Insights</h2>
            <div class="two-columns">
                <div>
                    <h3 style="color: var(--accent-green);">What Stays the Same</h3>
                    <ul>
                        <li>Core algorithm logic is <strong>identical</strong></li>
                        <li>Time complexity: O(k) for Bloom/CMS/HLL</li>
                        <li>Space complexity: sublinear (O(1) per element)</li>
                        <li>Error bounds and guarantees</li>
                        <li>Hash function requirements</li>
                        <li>Trade-off: accuracy vs memory</li>
                        <li>One-sided error properties</li>
                    </ul>
                </div>
                <div>
                    <h3 style="color: var(--accent-yellow);">What Changes</h3>
                    <ul>
                        <li>Syntax and keywords</li>
                        <li>Memory allocation patterns</li>
                        <li>Bit manipulation syntax</li>
                        <li>Hash function availability</li>
                        <li>Error handling approach</li>
                        <li>Type declarations</li>
                        <li>Library ecosystem</li>
                    </ul>
                </div>
            </div>
            <div class="info-box insight" style="margin-top: 30px;">
                <strong>The Big Picture:</strong> Probabilistic data structures achieve the impossible: approximate answers to questions that would otherwise require unbounded memory. The algorithm is the same regardless of language.
            </div>
        </div>

        <!-- Slide 19: Production Libraries -->
        <div class="slide">
            <h2>üì¶ Production Libraries</h2>
            <div class="two-columns">
                <div>
                    <h3 style="color: var(--accent-green);">C Libraries</h3>
                    <ul>
                        <li><strong>libbloom</strong> ‚Äî High-performance Bloom filter</li>
                        <li><strong>Redis</strong> ‚Äî Built-in HyperLogLog (PFADD/PFCOUNT)</li>
                        <li><strong>Google's CityHash</strong> ‚Äî Fast hash functions</li>
                        <li><strong>xxHash</strong> ‚Äî Extremely fast hashing</li>
                        <li><strong>LevelDB</strong> ‚Äî Skip List in memtable</li>
                    </ul>
                </div>
                <div>
                    <h3 style="color: var(--accent-yellow);">Python Libraries</h3>
                    <ul>
                        <li><strong>pybloom-live</strong> ‚Äî Bloom filters</li>
                        <li><strong>datasketch</strong> ‚Äî HLL, MinHash, LSH</li>
                        <li><strong>countminsketch</strong> ‚Äî CMS implementation</li>
                        <li><strong>mmh3</strong> ‚Äî MurmurHash3 bindings</li>
                        <li><strong>redis-py</strong> ‚Äî Redis HLL from Python</li>
                        <li><strong>sortedcontainers</strong> ‚Äî Skip List-like structures</li>
                    </ul>
                </div>
            </div>
            <div class="info-box note">
                <strong>Recommendation:</strong> Use production libraries for real applications. Our implementations are for learning the underlying algorithms.
            </div>
        </div>

        <!-- Slide 20: Questions -->
        <div class="slide title-slide">
            <h1>‚ùì Questions?</h1>
            <div class="subtitle">Probabilistic Data Structures ‚Äî Language Comparison</div>
            <p style="margin-top: 30px; color: var(--text-secondary);">
                Navigate: <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> or <kbd>Space</kbd>
            </p>
            <p style="margin-top: 20px; color: var(--text-secondary); font-size: 0.9em;">
                Week 17 | ATP Course | ASE-CSIE Bucharest
            </p>
        </div>

    </div>

    <!-- Navigation -->
    <div class="slide-counter">
        <span id="currentSlide">1</span> / <span id="totalSlides">20</span>
    </div>

    <div class="navigation">
        <button class="nav-btn" id="prevBtn" onclick="prevSlide()">‚Üê Previous</button>
        <button class="nav-btn" id="nextBtn" onclick="nextSlide()">Next ‚Üí</button>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        const progressBar = document.getElementById('progressBar');
        const currentSlideEl = document.getElementById('currentSlide');
        const totalSlidesEl = document.getElementById('totalSlides');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');

        totalSlidesEl.textContent = totalSlides;

        function showSlide(index) {
            slides.forEach(slide => slide.classList.remove('active'));
            slides[index].classList.add('active');
            
            const progress = ((index + 1) / totalSlides) * 100;
            progressBar.style.width = progress + '%';
            currentSlideEl.textContent = index + 1;
            
            prevBtn.disabled = index === 0;
            nextBtn.disabled = index === totalSlides - 1;
        }

        function nextSlide() {
            if (currentSlide < totalSlides - 1) {
                currentSlide++;
                showSlide(currentSlide);
            }
        }

        function prevSlide() {
            if (currentSlide > 0) {
                currentSlide--;
                showSlide(currentSlide);
            }
        }

        document.addEventListener('keydown', function(e) {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                    e.preventDefault();
                    nextSlide();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    prevSlide();
                    break;
                case 'Home':
                    e.preventDefault();
                    currentSlide = 0;
                    showSlide(currentSlide);
                    break;
                case 'End':
                    e.preventDefault();
                    currentSlide = totalSlides - 1;
                    showSlide(currentSlide);
                    break;
            }
        });

        // Touch support for mobile
        let touchStartX = 0;
        let touchEndX = 0;
        
        document.addEventListener('touchstart', function(e) {
            touchStartX = e.changedTouches[0].screenX;
        });
        
        document.addEventListener('touchend', function(e) {
            touchEndX = e.changedTouches[0].screenX;
            if (touchStartX - touchEndX > 50) {
                nextSlide();
            } else if (touchEndX - touchStartX > 50) {
                prevSlide();
            }
        });

        // Initialise highlight.js
        hljs.highlightAll();
        showSlide(0);
    </script>
</body>
</html>
