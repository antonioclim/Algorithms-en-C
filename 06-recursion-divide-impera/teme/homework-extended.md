# Extended challenges: Week 06 (Queues)

## 1. Rationale

The extended challenges are optional and are intended to deepen conceptual understanding beyond the minimum laboratory outcomes. In each task the queue discipline is not an incidental implementation detail but the organising principle of the solution. Correctness therefore depends on articulating the queue invariants and then designing algorithms that preserve them under all input schedules.

Unless stated otherwise the implementation language is ISO C11 and external libraries are discouraged. Where a task references a deque you should interpret this as a double-ended queue with O(1) amortised operations at both ends.

Each correctly solved challenge is worth **+10 bonus points** up to a maximum of +50.

## 2. Challenge 1: Sliding-window maximum via a deque

### 2.1 Problem statement

Given an integer array `A[0..n-1]` and a window size `k` (1 ≤ k ≤ n) compute the maximum value for every contiguous window of length `k`.

### 2.2 Required complexity

- Time: **O(n)**
- Space: **O(k)** auxiliary (beyond input and output)

### 2.3 Core invariant and algorithmic idea

Maintain a deque of indices such that:

- Indices are increasing from front to back (they remain in array order).
- Values `A[idx]` are **strictly decreasing** from front to back.

Consequently the front always holds the index of the maximum in the current window.

### 2.4 Pseudocode

```
procedure SLIDING_WINDOW_MAX(A, n, k):
    D := empty deque  // stores indices
    for i in 0 .. n-1:
        // 1) expire indices that fall out of the window
        while D not empty and D.front <= i-k:
            D.pop_front()

        // 2) maintain decreasing values
        while D not empty and A[D.back] <= A[i]:
            D.pop_back()

        // 3) append current index
        D.push_back(i)

        // 4) emit answer once the first window closes
        if i >= k-1:
            output A[D.front]
```

### 2.5 Implementation sketch in C

A fixed-capacity circular deque is adequate because the deque holds at most `k` indices.

```c
typedef struct {
    int *idx;          /* indices into A */
    int front, rear;   /* modulo capacity */
    int count;
    int capacity;
} Deque;

/* push_back, pop_back, push_front, pop_front are O(1) with modulo arithmetic */
```

### 2.6 Edge cases

- `k = 1` yields the original array.
- Arrays with repeated values require a consistent tie rule. The pseudocode uses `<=` so newer equal values replace older ones which avoids unnecessary growth.

## 3. Challenge 2: Queue implemented with two stacks

### 3.1 Target interface

Support `enqueue(x)`, `dequeue()`, `peek()` and `is_empty()`.

### 3.2 Amortised analysis

Use two stacks:

- `S_in` collects enqueued elements.
- `S_out` serves dequeues.

When `S_out` becomes empty move all elements from `S_in` to `S_out` which reverses order and exposes the oldest element on top.

### 3.3 Pseudocode

```
procedure ENQUEUE(x):
    S_in.push(x)

procedure TRANSFER_IF_NEEDED():
    if S_out.empty():
        while not S_in.empty():
            S_out.push(S_in.pop())

procedure DEQUEUE():
    TRANSFER_IF_NEEDED()
    if S_out.empty(): error underflow
    return S_out.pop()

procedure PEEK():
    TRANSFER_IF_NEEDED()
    if S_out.empty(): error underflow
    return S_out.top()
```

The amortised O(1) bound follows from a potential argument: each element is moved from `S_in` to `S_out` at most once.

### 3.4 C implementation notes

If your stack is a dynamic array you should double capacity on overflow. You should also expose a `stack_destroy` function to release memory.

## 4. Challenge 3: Snake simulation as a queue of coordinates

### 4.1 Queue interpretation

Represent the snake body as an ordered sequence of grid cells. Each tick:

- The new head cell is enqueued.
- The tail cell is dequeued unless food was consumed.

### 4.2 Correctness invariant

The queue contains the snake cells in spatial order from tail (front) to head (rear-1). No cell may appear twice.

### 4.3 Pseudocode

```
procedure STEP(direction):
    new_head := head + delta(direction)
    if new_head hits wall: terminate
    if new_head in body: terminate

    enqueue(new_head)

    if new_head == food:
        spawn new food
    else:
        dequeue(tail)
```

### 4.4 Practical considerations

- Membership tests `new_head in body` are O(length) if performed naively. For acceptable performance maintain an auxiliary boolean grid `occupied[x][y]`.
- Food generation should sample uniformly from the free cells.

## 5. Challenge 4: Bank simulation with multiple counters

### 5.1 Model

Each counter has its own FIFO queue. Arrivals join the shortest queue. Service times are random.

### 5.2 Distributions

You do not need to implement exact Poisson or exponential processes but you should approximate the intended behaviour.

- Inter-arrival times can be generated by a geometric distribution in discrete time.
- Service times can be generated similarly.

### 5.3 Key algorithmic problem

This is a discrete-event simulation with competing events:

- Customer arrivals
- Service completion at each counter

A priority queue is the canonical solution but a sufficiently small number of counters permits an O(N) scan per event.

## 6. Challenge 5: Lock-free queue

### 6.1 Scope warning

A correct lock-free queue is an advanced concurrency exercise. If you attempt it you must specify:

- The memory model assumptions
- The atomic primitives used
- The correctness criterion (linearizability)

### 6.2 Suggested reference design

The Michael–Scott queue is a standard baseline. It uses a linked list with a dummy node and two atomic pointers `Head` and `Tail` updated via compare-and-swap.

High-level pseudocode:

```
procedure ENQ(x):
    node := new Node(x)
    loop:
        tail := Tail
        next := tail.next
        if tail == Tail:
            if next == null:
                if CAS(tail.next, null, node):
                    CAS(Tail, tail, node)
                    return
            else:
                CAS(Tail, tail, next)
```

This task is assessed primarily on correctness reasoning rather than raw throughput.

## 7. References

| APA (7th ed) reference | DOI |
|---|---|
| Little, J. D. C. (1961). A proof for the queuing formula: L = λW. *Operations Research, 9*(3), 383–387. | https://doi.org/10.1287/opre.9.3.383 citeturn0search0 |
| Michael, M. M., & Scott, M. L. (1996). Simple, fast and practical non-blocking and blocking concurrent queue algorithms. In *Proceedings of the Fifteenth Annual ACM Symposium on Principles of Distributed Computing* (pp. 267–275). ACM. | https://doi.org/10.1145/248052.248106 citeturn0search1 |

## 7. Methodological appendix: proving performance claims

When an extended challenge specifies an asymptotic bound (for example O(n) for the sliding-window maximum) the expectation is not merely that the final programme appears to run quickly on small inputs but that you can justify the bound from first principles.

A minimal proof sketch should contain:

1. **A counting argument** that bounds the number of deque operations by a linear function of n.
2. **An explicit statement of the potential function** or amortisation invariant if the argument is amortised.
3. **A space bound** expressed in terms of the maximal queue occupancy and the representation used.

Example: in the monotone deque method, each index is inserted once and removed at most once from the front and at most once from the back. Therefore the total number of deque mutations is O(n) even though a single iteration may perform multiple pops.

## 8. References

| APA (7th ed) reference | DOI |
|---|---|
| Little, J. D. C. (1961). A proof for the queuing formula: L = λW. *Operations Research, 9*(3), 383–387. | https://doi.org/10.1287/opre.9.3.383 citeturn0search0 |
| Michael, M. M., & Scott, M. L. (1996). Simple, fast and practical non-blocking and blocking concurrent queue algorithms. In *Proceedings of the Fifteenth Annual ACM Symposium on Principles of Distributed Computing* (pp. 267–275). ACM. | https://doi.org/10.1145/248052.248106 citeturn0search1 |
